<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Messaging / IPC</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="riot-logo.png"/></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">DecaRange RTLS ARM Application</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Messaging / IPC</div>  </div>
</div><!--header-->
<div class="contents">

<p>Messaging API for inter process communication.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:msg_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msg_8h.html">msg.h</a></td></tr>
<tr class="memdesc:msg_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Messaging API for inter process communication. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:msg_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="msg_8c.html">msg.c</a></td></tr>
<tr class="memdesc:msg_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel messaging implementation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmsg__t.html">msg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a message object which can be sent between threads.  <a href="structmsg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gadba0f57bc141ce3a7ec95fbd4bf26429"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__msg.html#gadba0f57bc141ce3a7ec95fbd4bf26429">KERNEL_PID_ISR</a>&#160;&#160;&#160;(<a class="el" href="group__core__util.html#ga8328107b84cbf548fa267bffd8a0496c">KERNEL_PID_LAST</a> + 1)</td></tr>
<tr class="separator:gadba0f57bc141ce3a7ec95fbd4bf26429"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac5347725c3d203ac72604c0ab8b7d6d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__msg.html#gac5347725c3d203ac72604c0ab8b7d6d8">msg_send</a> (<a class="el" href="structmsg__t.html">msg_t</a> *<a class="el" href="minstd_8c.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a>, <a class="el" href="group__core__util.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> target_pid)</td></tr>
<tr class="memdesc:gac5347725c3d203ac72604c0ab8b7d6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message (blocking).  <a href="#gac5347725c3d203ac72604c0ab8b7d6d8">More...</a><br /></td></tr>
<tr class="separator:gac5347725c3d203ac72604c0ab8b7d6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99264bd4f263fa2b478308c1f7983c10"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__msg.html#ga99264bd4f263fa2b478308c1f7983c10">msg_try_send</a> (<a class="el" href="structmsg__t.html">msg_t</a> *<a class="el" href="minstd_8c.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a>, <a class="el" href="group__core__util.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> target_pid)</td></tr>
<tr class="memdesc:ga99264bd4f263fa2b478308c1f7983c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message (non-blocking).  <a href="#ga99264bd4f263fa2b478308c1f7983c10">More...</a><br /></td></tr>
<tr class="separator:ga99264bd4f263fa2b478308c1f7983c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8711110548c90fe5ca82215e89bb83dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__msg.html#ga8711110548c90fe5ca82215e89bb83dd">msg_send_to_self</a> (<a class="el" href="structmsg__t.html">msg_t</a> *<a class="el" href="minstd_8c.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a>)</td></tr>
<tr class="memdesc:ga8711110548c90fe5ca82215e89bb83dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the current thread.  <a href="#ga8711110548c90fe5ca82215e89bb83dd">More...</a><br /></td></tr>
<tr class="separator:ga8711110548c90fe5ca82215e89bb83dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2762c096056c5eac7ffe38c8727e033a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__msg.html#ga2762c096056c5eac7ffe38c8727e033a">msg_send_int</a> (<a class="el" href="structmsg__t.html">msg_t</a> *<a class="el" href="minstd_8c.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a>, <a class="el" href="group__core__util.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> target_pid)</td></tr>
<tr class="memdesc:ga2762c096056c5eac7ffe38c8727e033a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send message from interrupt.  <a href="#ga2762c096056c5eac7ffe38c8727e033a">More...</a><br /></td></tr>
<tr class="separator:ga2762c096056c5eac7ffe38c8727e033a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e05f08bd71d6f65dc727624c4d5f7a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__msg.html#gae3e05f08bd71d6f65dc727624c4d5f7a">msg_receive</a> (<a class="el" href="structmsg__t.html">msg_t</a> *<a class="el" href="minstd_8c.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a>)</td></tr>
<tr class="memdesc:gae3e05f08bd71d6f65dc727624c4d5f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive a message.  <a href="#gae3e05f08bd71d6f65dc727624c4d5f7a">More...</a><br /></td></tr>
<tr class="separator:gae3e05f08bd71d6f65dc727624c4d5f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a5e88bf7d9cadb41e5acf4deb300061"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__msg.html#ga0a5e88bf7d9cadb41e5acf4deb300061">msg_try_receive</a> (<a class="el" href="structmsg__t.html">msg_t</a> *<a class="el" href="minstd_8c.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a>)</td></tr>
<tr class="memdesc:ga0a5e88bf7d9cadb41e5acf4deb300061"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to receive a message.  <a href="#ga0a5e88bf7d9cadb41e5acf4deb300061">More...</a><br /></td></tr>
<tr class="separator:ga0a5e88bf7d9cadb41e5acf4deb300061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01aee21f8554591c7933d4ba05cfe85b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__msg.html#ga01aee21f8554591c7933d4ba05cfe85b">msg_send_receive</a> (<a class="el" href="structmsg__t.html">msg_t</a> *<a class="el" href="minstd_8c.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a>, <a class="el" href="structmsg__t.html">msg_t</a> *reply, <a class="el" href="group__core__util.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> target_pid)</td></tr>
<tr class="memdesc:ga01aee21f8554591c7933d4ba05cfe85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message, block until reply received.  <a href="#ga01aee21f8554591c7933d4ba05cfe85b">More...</a><br /></td></tr>
<tr class="separator:ga01aee21f8554591c7933d4ba05cfe85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e7b09dc269eb4847f6e08b9900ffda9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__msg.html#ga2e7b09dc269eb4847f6e08b9900ffda9">msg_reply</a> (<a class="el" href="structmsg__t.html">msg_t</a> *<a class="el" href="minstd_8c.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a>, <a class="el" href="structmsg__t.html">msg_t</a> *reply)</td></tr>
<tr class="memdesc:ga2e7b09dc269eb4847f6e08b9900ffda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replies to a message.  <a href="#ga2e7b09dc269eb4847f6e08b9900ffda9">More...</a><br /></td></tr>
<tr class="separator:ga2e7b09dc269eb4847f6e08b9900ffda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09edaaa9af7fca0a049459038b087583"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__msg.html#ga09edaaa9af7fca0a049459038b087583">msg_reply_int</a> (<a class="el" href="structmsg__t.html">msg_t</a> *<a class="el" href="minstd_8c.html#a00626facb4f86efb8618a4c5f5c3c5f8">m</a>, <a class="el" href="structmsg__t.html">msg_t</a> *reply)</td></tr>
<tr class="memdesc:ga09edaaa9af7fca0a049459038b087583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replies to a message from interrupt.  <a href="#ga09edaaa9af7fca0a049459038b087583">More...</a><br /></td></tr>
<tr class="separator:ga09edaaa9af7fca0a049459038b087583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1353dec9af776d4caf5f4e00cec112e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__msg.html#gad1353dec9af776d4caf5f4e00cec112e">msg_avail</a> (void)</td></tr>
<tr class="memdesc:gad1353dec9af776d4caf5f4e00cec112e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check how many messages are available in the message queue.  <a href="#gad1353dec9af776d4caf5f4e00cec112e">More...</a><br /></td></tr>
<tr class="separator:gad1353dec9af776d4caf5f4e00cec112e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga480e6f32c8ab18579b62a890f3fda2cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__msg.html#ga480e6f32c8ab18579b62a890f3fda2cd">msg_init_queue</a> (<a class="el" href="structmsg__t.html">msg_t</a> *array, int num)</td></tr>
<tr class="memdesc:ga480e6f32c8ab18579b62a890f3fda2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the current thread's message queue.  <a href="#ga480e6f32c8ab18579b62a890f3fda2cd">More...</a><br /></td></tr>
<tr class="separator:ga480e6f32c8ab18579b62a890f3fda2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43b46e5167cdf2b2324920b59dae81a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__core__msg.html#ga43b46e5167cdf2b2324920b59dae81a0">msg_queue_print</a> (void)</td></tr>
<tr class="memdesc:ga43b46e5167cdf2b2324920b59dae81a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the message queue of the current thread.  <a href="#ga43b46e5167cdf2b2324920b59dae81a0">More...</a><br /></td></tr>
<tr class="separator:ga43b46e5167cdf2b2324920b59dae81a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Messaging API for inter process communication. </p>
<h1>Messages </h1>
<p>IPC messages consist of a sender PID, a type, and some content. The sender PID will be set by the IPC internally and is not required to be set by the user. The type helps the receiver to multiplex different message types and should be set to a system-wide unique value. The content can either be provided as a 32-bit integer or a pointer.</p>
<h1>Blocking vs non-blocking </h1>
<p>Messages can be sent and received blocking and non-blocking. Both can be used combined: A message send while blocking the sender thread can be received with the non-blocking variant and vice-versa.</p>
<h2>Blocking IPC </h2>
<p>For the blocking variant use <a class="el" href="group__core__msg.html#gac5347725c3d203ac72604c0ab8b7d6d8">msg_send()</a> or <a class="el" href="group__core__msg.html#gae3e05f08bd71d6f65dc727624c4d5f7a">msg_receive()</a> respectively.</p>
<p>Additionally, one can use <a class="el" href="group__core__msg.html#ga01aee21f8554591c7933d4ba05cfe85b">msg_send_receive()</a> to simultaneously block the sending thread and expect a response from the receiving thread. In this case, the receiving thread must use <a class="el" href="group__core__msg.html#ga2e7b09dc269eb4847f6e08b9900ffda9">msg_reply()</a> to reply to the message of the sender thread.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="inttypes_8h.html">inttypes.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdio_8h.html">stdio.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="msg_8h.html">msg.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="thread_8h.html">thread.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="group__core__util.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> rcv_pid;</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">char</span> rcv_stack[<a class="code" href="boards_2qemu-i386_2include_2cpu__conf_8h.html#a713ebddc00581f4d415095cdbfd8791f">THREAD_STACKSIZE_DEFAULT</a>];</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *rcv(<span class="keywordtype">void</span> *arg)</div><div class="line">{</div><div class="line">    <a class="code" href="structmsg__t.html">msg_t</a> msg_req, msg_resp;</div><div class="line"></div><div class="line">    (void)arg;</div><div class="line">    <span class="keywordflow">while</span> (1) {</div><div class="line">        <a class="code" href="group__core__msg.html#gae3e05f08bd71d6f65dc727624c4d5f7a">msg_receive</a>(&amp;msg_req);</div><div class="line">        msg_resp.<a class="code" href="structmsg__t.html#ae0dd071afd4c761faee99d3ecd2bbb0d">content</a>.<a class="code" href="structmsg__t.html#ae7f66047e6e39ba2bb6af8b95f00d1dd">value</a> = msg_req.<a class="code" href="structmsg__t.html#ae0dd071afd4c761faee99d3ecd2bbb0d">content</a>.<a class="code" href="structmsg__t.html#ae7f66047e6e39ba2bb6af8b95f00d1dd">value</a> + 1;</div><div class="line">        <a class="code" href="group__core__msg.html#ga2e7b09dc269eb4847f6e08b9900ffda9">msg_reply</a>(&amp;msg_req, &amp;msg_resp);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="std_impl_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="cksum__test_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="structmsg__t.html">msg_t</a> msg_req, msg_resp;</div><div class="line"></div><div class="line">    msg_resp.<a class="code" href="structmsg__t.html#ae0dd071afd4c761faee99d3ecd2bbb0d">content</a>.<a class="code" href="structmsg__t.html#ae7f66047e6e39ba2bb6af8b95f00d1dd">value</a> = 0;</div><div class="line">    rcv_pid = <a class="code" href="thread_8h.html#a87c94d383e64a09974fc8665f82a99b3">thread_create</a>(rcv_stack, <span class="keyword">sizeof</span>(rcv_stack),</div><div class="line">                            <a class="code" href="thread_8h.html#ac57374d1c51374ebf95d9679281af818">THREAD_PRIORITY_MAIN</a> - 1, 0, rcv, <a class="code" href="std_impl_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <span class="stringliteral">&quot;rcv&quot;</span>);</div><div class="line">    <span class="keywordflow">while</span> (1) {</div><div class="line">        msg_req.<a class="code" href="structmsg__t.html#ae0dd071afd4c761faee99d3ecd2bbb0d">content</a>.<a class="code" href="structmsg__t.html#ae7f66047e6e39ba2bb6af8b95f00d1dd">value</a> = msg_resp.<a class="code" href="structmsg__t.html#ae0dd071afd4c761faee99d3ecd2bbb0d">content</a>.<a class="code" href="structmsg__t.html#ae7f66047e6e39ba2bb6af8b95f00d1dd">value</a>;</div><div class="line">        <a class="code" href="group__core__msg.html#ga01aee21f8554591c7933d4ba05cfe85b">msg_send_receive</a>(&amp;msg_req, &amp;msg_resp, rcv_pid);</div><div class="line">        <a class="code" href="pll__freq_8m.html#a9a95eca22a70333f9ea42672239eb55e">printf</a>(<span class="stringliteral">&quot;Result: %&quot;</span> PRIu32 <span class="stringliteral">&quot;\n&quot;</span>, msg_resp.<a class="code" href="structmsg__t.html#ae0dd071afd4c761faee99d3ecd2bbb0d">content</a>.<a class="code" href="structmsg__t.html#ae7f66047e6e39ba2bb6af8b95f00d1dd">value</a>);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h2>Non-blocking IPC </h2>
<p>For the non-blocking variant use <a class="el" href="group__core__msg.html#ga99264bd4f263fa2b478308c1f7983c10">msg_try_send()</a> or <a class="el" href="group__core__msg.html#ga0a5e88bf7d9cadb41e5acf4deb300061">msg_try_receive()</a> respectively. If a message is sent in synchronous mode or the message queue (see below) of the receiving thread is full messages sent this way will be dropped.</p>
<p>You can use the example on asynchronous IPC below — but without the queue — to get an impression of how to use non-blocking IPC.</p>
<h1>Synchronous vs Asynchronous </h1>
<p>RIOT's IPC supports both synchronous and asynchronous IPC.</p>
<h2>Synchronous IPC </h2>
<p>Synchronous IPC is the default mode i.e. is active when the receiving thread has no message queue initialized. Messages that can't be delivered when sending non-blocking (because the receiver already received a message) or which are sent when the receiver is not receive-blocked will be dropped.</p>
<h2>Asynchronous IPC </h2>
<p>To use asynchronous IPC one needs to initialize a message queue using <a class="el" href="group__core__msg.html#ga480e6f32c8ab18579b62a890f3fda2cd">msg_init_queue()</a> (note that it <b>must</b> be of a size equal to a power of two). Messages sent to a thread with a message queue that isn't full are never dropped and the sending never blocks, even when using <a class="el" href="group__core__msg.html#gac5347725c3d203ac72604c0ab8b7d6d8">msg_send()</a>. If the queue is full and the sending thread has a higher priority than the receiving thread the send-behavior is equivalent to synchronous mode.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="inttypes_8h.html">inttypes.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="stdio_8h.html">stdio.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="msg_8h.html">msg.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="thread_8h.html">thread.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define RCV_QUEUE_SIZE  (8)</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="group__core__util.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a> rcv_pid;</div><div class="line"><span class="keyword">static</span> <span class="keywordtype">char</span> rcv_stack[<a class="code" href="boards_2qemu-i386_2include_2cpu__conf_8h.html#a713ebddc00581f4d415095cdbfd8791f">THREAD_STACKSIZE_DEFAULT</a> + <a class="code" href="boards_2qemu-i386_2include_2cpu__conf_8h.html#af30305c0f413c7da1e7445de2b5ea5a5">THREAD_EXTRA_STACKSIZE_PRINTF</a>];</div><div class="line"><span class="keyword">static</span> <a class="code" href="structmsg__t.html">msg_t</a> rcv_queue[RCV_QUEUE_SIZE];</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> *rcv(<span class="keywordtype">void</span> *arg)</div><div class="line">{</div><div class="line">    <a class="code" href="structmsg__t.html">msg_t</a> msg;</div><div class="line"></div><div class="line">    (void)arg;</div><div class="line">    <a class="code" href="group__core__msg.html#ga480e6f32c8ab18579b62a890f3fda2cd">msg_init_queue</a>(rcv_queue, RCV_QUEUE_SIZE);</div><div class="line">    <span class="keywordflow">while</span> (1) {</div><div class="line">        <a class="code" href="group__core__msg.html#gae3e05f08bd71d6f65dc727624c4d5f7a">msg_receive</a>(&amp;msg);</div><div class="line">        <a class="code" href="pll__freq_8m.html#a9a95eca22a70333f9ea42672239eb55e">printf</a>(<span class="stringliteral">&quot;Received %&quot;</span> PRIu32 <span class="stringliteral">&quot;\n&quot;</span>, msg.<a class="code" href="structmsg__t.html#ae0dd071afd4c761faee99d3ecd2bbb0d">content</a>.<a class="code" href="structmsg__t.html#ae7f66047e6e39ba2bb6af8b95f00d1dd">value</a>);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="std_impl_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> <a class="code" href="cksum__test_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main</a>(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <a class="code" href="structmsg__t.html">msg_t</a> msg;</div><div class="line"></div><div class="line">    msg.<a class="code" href="structmsg__t.html#ae0dd071afd4c761faee99d3ecd2bbb0d">content</a>.<a class="code" href="structmsg__t.html#ae7f66047e6e39ba2bb6af8b95f00d1dd">value</a> = 0;</div><div class="line">    rcv_pid = <a class="code" href="thread_8h.html#a87c94d383e64a09974fc8665f82a99b3">thread_create</a>(rcv_stack, <span class="keyword">sizeof</span>(rcv_stack),</div><div class="line">                            <a class="code" href="thread_8h.html#ac57374d1c51374ebf95d9679281af818">THREAD_PRIORITY_MAIN</a> - 1, 0, rcv, <a class="code" href="std_impl_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <span class="stringliteral">&quot;rcv&quot;</span>);</div><div class="line">    <span class="keywordflow">while</span> (1) {</div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__core__msg.html#ga99264bd4f263fa2b478308c1f7983c10">msg_try_send</a>(&amp;msg, rcv_pid) == 0) {</div><div class="line">            <a class="code" href="pll__freq_8m.html#a9a95eca22a70333f9ea42672239eb55e">printf</a>(<span class="stringliteral">&quot;Receiver queue full.\n&quot;</span>);</div><div class="line">        }</div><div class="line">        msg.<a class="code" href="structmsg__t.html#ae0dd071afd4c761faee99d3ecd2bbb0d">content</a>.<a class="code" href="structmsg__t.html#ae7f66047e6e39ba2bb6af8b95f00d1dd">value</a>++;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><h1>Timing &amp; messages </h1>
<p>Timing out the reception of a message or sending messages at a certain time is out of scope for the basic IPC provided by the kernel. See the <a class="el" href="group__sys__xtimer.html">xtimer</a> module on information for these functionalities. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gadba0f57bc141ce3a7ec95fbd4bf26429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadba0f57bc141ce3a7ec95fbd4bf26429">&#9670;&nbsp;</a></span>KERNEL_PID_ISR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KERNEL_PID_ISR&#160;&#160;&#160;(<a class="el" href="group__core__util.html#ga8328107b84cbf548fa267bffd8a0496c">KERNEL_PID_LAST</a> + 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Value of <a class="el" href="structmsg__t.html#a8d65b24be232f04f4f06a7e09eda691c">msg_t::sender_pid</a> if the sender was an interrupt service routine. </p>

<p class="definition">Definition at line <a class="el" href="msg_8h_source.html#l00253">253</a> of file <a class="el" href="msg_8h_source.html">msg.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad1353dec9af776d4caf5f4e00cec112e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1353dec9af776d4caf5f4e00cec112e">&#9670;&nbsp;</a></span>msg_avail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msg_avail </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check how many messages are available in the message queue. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of messages available in our queue on success </dd>
<dd>
-1, if no caller's message queue is initialized </dd></dl>

</div>
</div>
<a id="ga480e6f32c8ab18579b62a890f3fda2cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga480e6f32c8ab18579b62a890f3fda2cd">&#9670;&nbsp;</a></span>msg_init_queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msg_init_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the current thread's message queue. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>num</code> <b>MUST BE A POWER OF TWO!</b></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">array</td><td>Pointer to preallocated array of <code><a class="el" href="structmsg__t.html" title="Describes a message object which can be sent between threads. ">msg_t</a></code> structures, must not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>Number of <code><a class="el" href="structmsg__t.html" title="Describes a message object which can be sent between threads. ">msg_t</a></code> structures in array. <b>MUST BE POWER OF TWO!</b> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga43b46e5167cdf2b2324920b59dae81a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43b46e5167cdf2b2324920b59dae81a0">&#9670;&nbsp;</a></span>msg_queue_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void msg_queue_print </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the message queue of the current thread. </p>

</div>
</div>
<a id="gae3e05f08bd71d6f65dc727624c4d5f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3e05f08bd71d6f65dc727624c4d5f7a">&#9670;&nbsp;</a></span>msg_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msg_receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receive a message. </p>
<p>This function blocks until a message was received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to preallocated <code><a class="el" href="structmsg__t.html" title="Describes a message object which can be sent between threads. ">msg_t</a></code> structure, must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1, Function always succeeds or blocks forever. </dd></dl>

</div>
</div>
<a id="ga2e7b09dc269eb4847f6e08b9900ffda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e7b09dc269eb4847f6e08b9900ffda9">&#9670;&nbsp;</a></span>msg_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msg_reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>reply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replies to a message. </p>
<p>Sender must have sent the message with <a class="el" href="group__core__msg.html#ga01aee21f8554591c7933d4ba05cfe85b" title="Send a message, block until reply received. ">msg_send_receive()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>message to reply to, must not be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reply</td><td>message that target will get as reply, must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1, if successful </dd>
<dd>
-1, on error </dd></dl>

</div>
</div>
<a id="ga09edaaa9af7fca0a049459038b087583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09edaaa9af7fca0a049459038b087583">&#9670;&nbsp;</a></span>msg_reply_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msg_reply_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>reply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replies to a message from interrupt. </p>
<p>An ISR can obviously not receive messages, however a thread might delegate replying to a message to an ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>message to reply to, must not be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reply</td><td>message that target will get as reply, must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1, if successful </dd>
<dd>
-1, on error </dd></dl>

</div>
</div>
<a id="gac5347725c3d203ac72604c0ab8b7d6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5347725c3d203ac72604c0ab8b7d6d8">&#9670;&nbsp;</a></span>msg_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msg_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__util.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>target_pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message (blocking). </p>
<p>This function sends a message to another thread. The <code><a class="el" href="structmsg__t.html" title="Describes a message object which can be sent between threads. ">msg_t</a></code> structure has to be allocated (e.g. on the stack) before calling the function and can be freed afterwards. If called from an interrupt, this function will never block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Pointer to preallocated <code><a class="el" href="structmsg__t.html" title="Describes a message object which can be sent between threads. ">msg_t</a></code> structure, must not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_pid</td><td>PID of target thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1, if sending was successful (message delivered directly or to a queue) </dd>
<dd>
0, if called from ISR and receiver cannot receive the message now (it is not waiting or it's message queue is full) </dd>
<dd>
-1, on error (invalid PID) </dd></dl>

</div>
</div>
<a id="ga2762c096056c5eac7ffe38c8727e033a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2762c096056c5eac7ffe38c8727e033a">&#9670;&nbsp;</a></span>msg_send_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msg_send_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__util.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>target_pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send message from interrupt. </p>
<p>Will be automatically chosen instead of <a class="el" href="group__core__msg.html#gac5347725c3d203ac72604c0ab8b7d6d8" title="Send a message (blocking). ">msg_send()</a> if called from an interrupt/ISR.</p>
<p>The value of <code>m-&gt;sender_pid</code> is set to <a class="el" href="group__core__msg.html#gadba0f57bc141ce3a7ec95fbd4bf26429">KERNEL_PID_ISR</a>.</p>
<dl class="section see"><dt>See also</dt><dd>msg_sent_by_int()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Pointer to preallocated <a class="el" href="structmsg__t.html">msg_t</a> structure, must not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_pid</td><td>PID of target thread.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1, if sending was successful </dd>
<dd>
0, if receiver is not waiting and <code>block == 0</code> </dd>
<dd>
-1, on error (invalid PID) </dd></dl>

</div>
</div>
<a id="ga01aee21f8554591c7933d4ba05cfe85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01aee21f8554591c7933d4ba05cfe85b">&#9670;&nbsp;</a></span>msg_send_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msg_send_receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>reply</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__util.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>target_pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message, block until reply received. </p>
<p>This function sends a message to <em>target_pid</em> and then blocks until target has sent a reply which is then stored in <em>reply</em>.</p>
<dl class="section pre"><dt>Precondition</dt><dd><code>target_pid</code> is not the PID of the current thread.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Pointer to preallocated <code><a class="el" href="structmsg__t.html" title="Describes a message object which can be sent between threads. ">msg_t</a></code> structure with the message to send, must not be NULL. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">reply</td><td>Pointer to preallocated msg. Reply will be written here, must not be NULL. <a class="el" href="struct_can.html">Can</a> be identical to <code>m</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_pid</td><td>The PID of the target process</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1, if successful. </dd></dl>

</div>
</div>
<a id="ga8711110548c90fe5ca82215e89bb83dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8711110548c90fe5ca82215e89bb83dd">&#9670;&nbsp;</a></span>msg_send_to_self()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msg_send_to_self </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to the current thread. </p>
<p>Will work only if the thread has a message queue.</p>
<p>Will be automatically chosen instead of <code>msg_send</code> if <code>target_pid</code> == <code>thread_pid</code>. This function never blocks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>pointer to message structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if sending was successful </dd>
<dd>
0 if the thread's message queue is full (or inexistent) </dd></dl>

</div>
</div>
<a id="ga0a5e88bf7d9cadb41e5acf4deb300061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a5e88bf7d9cadb41e5acf4deb300061">&#9670;&nbsp;</a></span>msg_try_receive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msg_try_receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to receive a message. </p>
<p>This function does not block if no message can be received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">m</td><td>Pointer to preallocated <code><a class="el" href="structmsg__t.html" title="Describes a message object which can be sent between threads. ">msg_t</a></code> structure, must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1, if a message was received </dd>
<dd>
-1, otherwise. </dd></dl>

</div>
</div>
<a id="ga99264bd4f263fa2b478308c1f7983c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99264bd4f263fa2b478308c1f7983c10">&#9670;&nbsp;</a></span>msg_try_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int msg_try_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmsg__t.html">msg_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__core__util.html#ga8375139300d7cbf23bd8bd89ddddbe84">kernel_pid_t</a>&#160;</td>
          <td class="paramname"><em>target_pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message (non-blocking). </p>
<p>This function sends a message to another thread. The <code><a class="el" href="structmsg__t.html" title="Describes a message object which can be sent between threads. ">msg_t</a></code> structure has to be allocated (e.g. on the stack) before calling the function and can be freed afterwards. This function will never block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Pointer to preallocated <code><a class="el" href="structmsg__t.html" title="Describes a message object which can be sent between threads. ">msg_t</a></code> structure, must not be NULL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_pid</td><td>PID of target thread</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1, if sending was successful (message delivered directly or to a queue) </dd>
<dd>
0, if receiver is not waiting or has a full message queue </dd>
<dd>
-1, on error (invalid PID) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon May 15 2017 18:57:35 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
